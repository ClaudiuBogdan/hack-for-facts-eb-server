/**
 * E2E Tests for SQL Condition Builders
 *
 * These tests verify that the SQL generated by the shared builder modules
 * executes correctly against a real PostgreSQL database.
 *
 * Test scenarios:
 * 1. Period filtering accuracy (MONTH, QUARTER, YEAR)
 * 2. NULL-safe exclusions
 * 3. Amount column correctness by frequency
 * 4. Combined filter queries
 */

import { sql } from 'kysely';
import { describe, it, expect, beforeAll } from 'vitest';

import { Frequency } from '@/common/types/temporal.js';
import {
  buildPeriodConditions,
  type PeriodSelection,
} from '@/modules/execution-analytics/shell/repo/period-filter-builder.js';
import {
  buildWhereConditions,
  toWhereClause,
  getAmountColumn,
  type AnalyticsSqlFilter,
  type SqlBuildContext,
} from '@/modules/execution-analytics/shell/repo/sql-condition-builder.js';

import { getTestClients } from '../infra/test-db.js';

import type { BudgetDbClient } from '@/infra/database/client.js';

// =============================================================================
// Test Helpers
// =============================================================================

let db: BudgetDbClient;

beforeAll(() => {
  const clients = getTestClients();
  db = clients.budgetDb;
});

/**
 * Executes a raw SQL query and returns the count of results.
 */
async function executeCountQuery(whereClause: string): Promise<number> {
  const query = `
    SELECT COUNT(*) as count
    FROM executionlineitems eli
    LEFT JOIN entities e ON eli.entity_cui = e.cui
    LEFT JOIN uats u ON e.uat_id = u.id
    ${whereClause}
  `;

  const result = await sql.raw<{ count: string }>(query).execute(db);
  return Number(result.rows[0]?.count ?? 0);
}

/**
 * Executes a raw SQL query and returns the sum of amounts.
 */
async function executeSumQuery(amountColumn: string, whereClause: string): Promise<number> {
  const query = `
    SELECT COALESCE(SUM(${amountColumn}), 0) as total
    FROM executionlineitems eli
    LEFT JOIN entities e ON eli.entity_cui = e.cui
    LEFT JOIN uats u ON e.uat_id = u.id
    ${whereClause}
  `;

  const result = await sql.raw<{ total: string }>(query).execute(db);
  return Number(result.rows[0]?.total ?? 0);
}

/**
 * Creates a minimal filter for testing.
 */
function createFilter(overrides: Partial<AnalyticsSqlFilter> = {}): AnalyticsSqlFilter {
  return {
    account_category: 'ch',
    report_period: {
      frequency: Frequency.YEAR,
      selection: { interval: { start: '2020', end: '2024' } },
    },
    ...overrides,
  };
}

/**
 * Creates a context with default joins enabled.
 */
function createContext(overrides: Partial<SqlBuildContext> = {}): SqlBuildContext {
  return {
    hasEntityJoin: true,
    hasUatJoin: true,
    ...overrides,
  };
}

// =============================================================================
// Period Filtering Tests
// =============================================================================

describe('Period Filtering SQL Execution', () => {
  describe('YEAR frequency', () => {
    it('generates valid SQL for year interval', async () => {
      const selection: PeriodSelection = {
        interval: { start: '2020', end: '2024' },
      };

      const conditions = buildPeriodConditions(selection, Frequency.YEAR);
      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

      // Query should execute without error
      const count = await executeCountQuery(whereClause);
      expect(count).toBeGreaterThanOrEqual(0);
    });

    it('generates valid SQL for discrete years', async () => {
      const selection: PeriodSelection = {
        dates: ['2020', '2022', '2024'],
      };

      const conditions = buildPeriodConditions(selection, Frequency.YEAR);
      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

      const count = await executeCountQuery(whereClause);
      expect(count).toBeGreaterThanOrEqual(0);
    });
  });

  describe('QUARTER frequency', () => {
    it('generates valid SQL for quarter interval', async () => {
      const selection: PeriodSelection = {
        interval: { start: '2023-Q1', end: '2024-Q4' },
      };

      const conditions = buildPeriodConditions(selection, Frequency.QUARTER);
      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

      const count = await executeCountQuery(whereClause);
      expect(count).toBeGreaterThanOrEqual(0);
    });

    it('generates valid SQL for discrete quarters', async () => {
      const selection: PeriodSelection = {
        dates: ['2023-Q1', '2023-Q3', '2024-Q2'],
      };

      const conditions = buildPeriodConditions(selection, Frequency.QUARTER);
      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

      const count = await executeCountQuery(whereClause);
      expect(count).toBeGreaterThanOrEqual(0);
    });

    it('tuple comparison works for cross-year intervals', async () => {
      const selection: PeriodSelection = {
        interval: { start: '2023-Q3', end: '2024-Q2' },
      };

      const conditions = buildPeriodConditions(selection, Frequency.QUARTER);

      // Should generate tuple comparison
      expect(conditions[0]).toContain('(eli.year, eli.quarter) >=');
      expect(conditions[1]).toContain('(eli.year, eli.quarter) <=');

      const whereClause = `WHERE ${conditions.join(' AND ')}`;
      const count = await executeCountQuery(whereClause);
      expect(count).toBeGreaterThanOrEqual(0);
    });
  });

  describe('MONTH frequency', () => {
    it('generates valid SQL for month interval', async () => {
      const selection: PeriodSelection = {
        interval: { start: '2024-01', end: '2024-06' },
      };

      const conditions = buildPeriodConditions(selection, Frequency.MONTH);
      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

      const count = await executeCountQuery(whereClause);
      expect(count).toBeGreaterThanOrEqual(0);
    });

    it('generates valid SQL for discrete months', async () => {
      const selection: PeriodSelection = {
        dates: ['2024-01', '2024-03', '2024-06', '2024-12'],
      };

      const conditions = buildPeriodConditions(selection, Frequency.MONTH);
      const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

      const count = await executeCountQuery(whereClause);
      expect(count).toBeGreaterThanOrEqual(0);
    });

    it('tuple comparison works for cross-year intervals', async () => {
      const selection: PeriodSelection = {
        interval: { start: '2023-11', end: '2024-03' },
      };

      const conditions = buildPeriodConditions(selection, Frequency.MONTH);

      // Should generate tuple comparison
      expect(conditions[0]).toContain('(eli.year, eli.month) >=');
      expect(conditions[1]).toContain('(eli.year, eli.month) <=');

      const whereClause = `WHERE ${conditions.join(' AND ')}`;
      const count = await executeCountQuery(whereClause);
      expect(count).toBeGreaterThanOrEqual(0);
    });
  });
});

// =============================================================================
// Full WHERE Clause Tests
// =============================================================================

describe('Full WHERE Clause SQL Execution', () => {
  it('generates valid SQL for basic filter', async () => {
    const filter = createFilter();
    const ctx = createContext();

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    const count = await executeCountQuery(whereClause);
    expect(count).toBeGreaterThanOrEqual(0);
  });

  it('generates valid SQL with all dimension filters', async () => {
    const filter = createFilter({
      report_type: 'Executie bugetara detaliata',
      entity_cuis: ['12345678', '87654321'],
      functional_codes: ['51', '54', '61'],
      economic_codes: ['10', '20'],
    });
    const ctx = createContext();

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    const count = await executeCountQuery(whereClause);
    expect(count).toBeGreaterThanOrEqual(0);
  });

  it('generates valid SQL with prefix filters', async () => {
    const filter = createFilter({
      functional_prefixes: ['51', '6'],
      economic_prefixes: ['10', '2'],
    });
    const ctx = createContext();

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    // Should contain LIKE clauses
    expect(whereClause).toContain('LIKE');

    const count = await executeCountQuery(whereClause);
    expect(count).toBeGreaterThanOrEqual(0);
  });

  it('generates valid SQL with geographic filters', async () => {
    const filter = createFilter({
      entity_types: ['uat', 'primarie'],
      county_codes: ['AB', 'CJ', 'B'],
      is_uat: true,
    });
    const ctx = createContext({ hasEntityJoin: true, hasUatJoin: true });

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    const count = await executeCountQuery(whereClause);
    expect(count).toBeGreaterThanOrEqual(0);
  });

  it('generates valid SQL with amount constraints', async () => {
    const filter = createFilter({
      item_min_amount: 1000,
      item_max_amount: 1000000,
    });
    const ctx = createContext();

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    // Should use ytd_amount for YEAR frequency
    expect(whereClause).toContain('ytd_amount');

    const count = await executeCountQuery(whereClause);
    expect(count).toBeGreaterThanOrEqual(0);
  });
});

// =============================================================================
// NULL-Safe Exclusion Tests
// =============================================================================

describe('NULL-Safe Exclusion SQL Execution', () => {
  it('generates valid SQL for entity_types exclusion with NULL handling', async () => {
    const filter = createFilter({
      exclude: { entity_types: ['ministry', 'agency'] },
    });
    const ctx = createContext({ hasEntityJoin: true });

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    // Should contain NULL-safe pattern
    expect(whereClause).toContain('IS NULL OR');
    expect(whereClause).toContain('NOT IN');

    const count = await executeCountQuery(whereClause);
    expect(count).toBeGreaterThanOrEqual(0);
  });

  it('generates valid SQL for county_codes exclusion with NULL handling', async () => {
    const filter = createFilter({
      exclude: { county_codes: ['B', 'IF'] },
    });
    const ctx = createContext({ hasUatJoin: true });

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    // Should contain NULL-safe pattern
    expect(whereClause).toContain('IS NULL OR');
    expect(whereClause).toContain('NOT IN');

    const count = await executeCountQuery(whereClause);
    expect(count).toBeGreaterThanOrEqual(0);
  });

  it('generates valid SQL for functional code exclusion', async () => {
    const filter = createFilter({
      exclude: {
        functional_codes: ['51', '54'],
        functional_prefixes: ['99'],
      },
    });
    const ctx = createContext();

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    // Should contain NOT IN and NOT LIKE
    expect(whereClause).toContain('NOT IN');
    expect(whereClause).toContain('NOT LIKE');

    const count = await executeCountQuery(whereClause);
    expect(count).toBeGreaterThanOrEqual(0);
  });

  it('economic exclusions are skipped for VN accounts', async () => {
    const filter = createFilter({
      account_category: 'vn',
      exclude: {
        economic_codes: ['10', '20'],
        economic_prefixes: ['3'],
      },
    });
    const ctx = createContext();

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    // Should NOT contain economic_code exclusions for VN
    expect(whereClause).not.toContain('economic_code NOT IN');
    expect(whereClause).not.toContain('economic_code NOT LIKE');

    const count = await executeCountQuery(whereClause);
    expect(count).toBeGreaterThanOrEqual(0);
  });
});

// =============================================================================
// Amount Column Tests
// =============================================================================

describe('Amount Column Selection', () => {
  it('uses monthly_amount for MONTH frequency', async () => {
    const filter = createFilter({
      report_period: {
        frequency: Frequency.MONTH,
        selection: { interval: { start: '2024-01', end: '2024-12' } },
      },
      item_min_amount: 0,
    });
    const ctx = createContext();

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    expect(whereClause).toContain('monthly_amount');

    const amountCol = getAmountColumn(Frequency.MONTH);
    const total = await executeSumQuery(amountCol, whereClause);
    expect(total).toBeGreaterThanOrEqual(0);
  });

  it('uses quarterly_amount for QUARTER frequency', async () => {
    const filter = createFilter({
      report_period: {
        frequency: Frequency.QUARTER,
        selection: { interval: { start: '2024-Q1', end: '2024-Q4' } },
      },
      item_min_amount: 0,
    });
    const ctx = createContext();

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    expect(whereClause).toContain('quarterly_amount');

    const amountCol = getAmountColumn(Frequency.QUARTER);
    const total = await executeSumQuery(amountCol, whereClause);
    expect(total).toBeGreaterThanOrEqual(0);
  });

  it('uses ytd_amount for YEAR frequency', async () => {
    const filter = createFilter({
      report_period: {
        frequency: Frequency.YEAR,
        selection: { interval: { start: '2020', end: '2024' } },
      },
      item_min_amount: 0,
    });
    const ctx = createContext();

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    expect(whereClause).toContain('ytd_amount');

    const amountCol = getAmountColumn(Frequency.YEAR);
    const total = await executeSumQuery(amountCol, whereClause);
    expect(total).toBeGreaterThanOrEqual(0);
  });
});

// =============================================================================
// Combined Filter Scenarios
// =============================================================================

describe('Combined Filter Scenarios', () => {
  it('handles complex filter with all options', async () => {
    const filter: AnalyticsSqlFilter = {
      account_category: 'ch',
      report_type: 'Executie bugetara detaliata',
      report_period: {
        frequency: Frequency.YEAR,
        selection: { interval: { start: '2020', end: '2024' } },
      },
      functional_codes: ['51', '54', '61'],
      functional_prefixes: ['65', '66'],
      entity_types: ['uat'],
      county_codes: ['AB', 'CJ'],
      item_min_amount: 1000,
      exclude: {
        entity_cuis: ['99999999'],
        functional_prefixes: ['99'],
      },
    };
    const ctx = createContext({ hasEntityJoin: true, hasUatJoin: true });

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    // Verify complex query executes
    const count = await executeCountQuery(whereClause);
    expect(count).toBeGreaterThanOrEqual(0);
  });

  it('handles empty filter gracefully', async () => {
    const filter = createFilter({
      report_period: {
        frequency: Frequency.YEAR,
        selection: {},
      },
    });
    const ctx = createContext({ hasEntityJoin: false, hasUatJoin: false });

    const conditions = buildWhereConditions(filter, ctx);
    const whereClause = toWhereClause(conditions);

    // Should still have basic conditions (account_category, is_yearly)
    expect(conditions.length).toBeGreaterThan(0);

    const count = await executeCountQuery(whereClause);
    expect(count).toBeGreaterThanOrEqual(0);
  });
});
